<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.2">Jekyll</generator><link href="http://localhost:4000/portfolio/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/portfolio/" rel="alternate" type="text/html" /><updated>2019-04-28T20:31:00+01:00</updated><id>http://localhost:4000/portfolio/</id><title type="html">Marco Moroni</title><subtitle>Ciao, here's my portfolio.</subtitle><entry><title type="html">Cities</title><link href="http://localhost:4000/portfolio/cities/" rel="alternate" type="text/html" title="Cities" /><published>2019-04-01T00:00:00+01:00</published><updated>2019-04-01T00:00:00+01:00</updated><id>http://localhost:4000/portfolio/cities</id><content type="html" xml:base="http://localhost:4000/portfolio/cities/">&lt;p&gt;This was my Honours Project for my degree in Games Development at Edinburgh Napier University. The most interesting part was discovering that procedural art is actually a thing. And it’s addicting.&lt;/p&gt;

&lt;p&gt;The project was divided in two parts. First, I studied and classified the different procedural content generation (PCG) techniques. Then, I picked some of them so to create a generator in Unity that would create cities similar to the ones drawn by &lt;a href=&quot;https://nokkasili.tumblr.com/&quot;&gt;Minna O.&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/cities/minna02.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/portfolio/assets/cities/minna03.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/portfolio/assets/cities/minna04.jpg&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/portfolio/assets/cities/minna05.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;These are some screenshots of the generated artefacts, which is in 3D and interactive. The third one has on orthographic projection, which I think looks better when you can only see an image (and not interact with the scene). I was extremely lucky to have the artist helping me  throughout the project: she made the assets used for the final system:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/cities/perspective-01.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/portfolio/assets/cities/perspective-03.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/portfolio/assets/cities/ortho-01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Needless to say, the final result is way more limited than initially imagined, however I’m extremely happy with what I’ve learnt, as this was my first time delving into PCG.&lt;/p&gt;

&lt;p&gt;You can try the generator online &lt;a href=&quot;https://marcomoroni.itch.io/architect&quot;&gt;here&lt;/a&gt;, and if you want to learn more about how I did it, keep reading!&lt;/p&gt;

&lt;h3 id=&quot;classification&quot;&gt;Classification&lt;/h3&gt;

&lt;p&gt;PCG techniques can be divided in two categories:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;additive techniques, where the artefacts are created: goblins and treasures are placed in a map, the loot of a chest is created, etc.;&lt;/li&gt;
  &lt;li&gt;substractive techniques, where the artefacts are filtered: the generator (or sometimes a human) needs to evaluate what has been produced and pick the correct or best ones.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here, I covered only additive techniques, and even so, the list of them is far from comprehensive. I described some of the most used algorithms, and I focused on the ones that I actually used. Here’s a short summary of the additive PCG algorithms:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Tiles: As the name suggests, when you have a bunch of equally sized tiles you can place them around following certain rules.&lt;/li&gt;
  &lt;li&gt;Grammars: These techniques usually consist on a set of rewriting rules, for example, if I have a rule such as &lt;em&gt;A → AB&lt;/em&gt;, I can iteratively expand a string &lt;em&gt;A&lt;/em&gt; in &lt;em&gt;AAB&lt;/em&gt;, &lt;em&gt;ABABB&lt;/em&gt; &lt;em&gt;ABBABBB&lt;/em&gt;, etc. This is called an L-system, and it was initially developed to describe how plants look. Fractal are also a type of grammar.&lt;/li&gt;
  &lt;li&gt;Distribution: Let’s say you need to populate a map with trees, you may want them to be at a certain distance from each other, or you may to have more of them in certain areas. You can use distribution techniques, which give you more control over randomness.&lt;/li&gt;
  &lt;li&gt;Parametric: Not really algorithm by itself, it usually refers to generators that can be controlled though parameters.&lt;/li&gt;
  &lt;li&gt;Interpretative: 2D Perlin noise can be interpreted as a black and white texture, which can then be used to create a terrain mesh.&lt;/li&gt;
  &lt;li&gt;Simulations: Yeah no, that involves things like neural networks and evolutionary algorithms, which are way out of the scope of this project.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;techniques-used&quot;&gt;Techniques used&lt;/h3&gt;

&lt;p&gt;For every category I identified their strengths and weaknesses, and then I picked the ones that better suited what I wanted to achieve.&lt;/p&gt;

&lt;p&gt;A city is made of multiple 2D layers in the &lt;em&gt;z&lt;/em&gt;-axis. Each layer is essentially a list of &lt;code class=&quot;highlighter-rouge&quot;&gt;BUILDING&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;TREE&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;BRIDGE&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;EMPTY_SPACE&lt;/code&gt;, etc., and this list is populated using a Markov chain, which is a distribution technique. The idea of a Markov chain is simple: the probability to pick a certain item depends on the preceding item, and these probabilities are represented with a &lt;em&gt;transition matrix&lt;/em&gt;, in which each cell contain the probability to have a item in a column after an item in a row. Using this method is possible to code rules such as “a bridge must be between two buildings” by (1) having the probability to pick a bridge &amp;gt; 0 only after a building and (2) having a probability of 100% to pick a building after a bridge.&lt;/p&gt;

&lt;p&gt;Next, I used L-systems to compose the buildings as a stack of blocks (like a LEGO construction). Similarly to Markov chains, L-systems are a list of items, but in this case the list gets expanded through following a set of &lt;em&gt;production rules&lt;/em&gt;. Unfortunately, I only used this algorithm in its simplest form to expand a building until it reached a certain height (the list would be something like &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;block&amp;gt;&amp;lt;block&amp;gt;&amp;lt;block&amp;gt;&amp;lt;block&amp;gt;&amp;lt;roof&amp;gt;&lt;/code&gt;), but I discovered how powerful they could be, in particular, as I wrote earlier, imagine what if in a rule such as &lt;em&gt;A → AB&lt;/em&gt;, &lt;em&gt;A&lt;/em&gt; and &lt;em&gt;B&lt;/em&gt; were shapes—the buildings could have much more complex shapes, &lt;a href=&quot;/portfolio/watercolour&quot;&gt;I would only need a procedural texture to fill it with&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;Finally, the system is ultimately parametric, and the parameters change either the transition matrix of the Markov chain or the production rules of the L-system.&lt;/p&gt;

&lt;h3 id=&quot;other-things-ive-learnt-but-i-didnt-use&quot;&gt;Other things I’ve learnt but I didn’t use&lt;/h3&gt;

&lt;p&gt;Where to even start?&lt;/p&gt;

&lt;p&gt;Definitely the biggest thing that I didn’t manage to implement were procedurally generated textures. Those would have allowed so much more diversity: the could fill any shape and have use many colour combinations. Being now a Google Search sensei I discovered what most procedural artist have in their toolbox: &lt;a href=&quot;https://processing.org/&quot;&gt;Processing&lt;/a&gt;, noise, noise with one more dimension so to have looping noise, normal distribution, just to name a few.&lt;/p&gt;

&lt;p&gt;Shape grammars. Yeah, I would start from scratch with that.&lt;/p&gt;

&lt;p&gt;Honestly, if you’ve never done it, just search for “procedural art”, finding new algorithms is like opening Christmas presents.&lt;/p&gt;

&lt;h3 id=&quot;academic-poster&quot;&gt;Academic poster&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/cities/poster_front.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/portfolio/assets/cities/poster_back.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="procedural generation" /><category term="unity" /><category term="C#" /><summary type="html">This was my Honours Project for my degree in Games Development at Edinburgh Napier University. The most interesting part was discovering that procedural art is actually a thing. And it’s addicting.</summary></entry><entry><title type="html">Watercolour</title><link href="http://localhost:4000/portfolio/watercolour/" rel="alternate" type="text/html" title="Watercolour" /><published>2019-03-27T00:00:00+00:00</published><updated>2019-03-27T00:00:00+00:00</updated><id>http://localhost:4000/portfolio/watercolour</id><content type="html" xml:base="http://localhost:4000/portfolio/watercolour/">&lt;p&gt;&lt;img src=&quot;/portfolio/assets/watercolour/textures.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;While working on my Honours Project I discovered the wonders of procedural generation, and now no one can stop me. I though procedural watercolour textures could be a good experiment to attempt and I found a couple of ways to do it. One is from &lt;a href=&quot;https://tylerxhobbs.com/essays/2017/a-generative-approach-to-simulating-watercolor-paints&quot;&gt;Tyler Hobbs&lt;/a&gt;, in which a shape is deformed multiple times, and the other is from &lt;a href=&quot;https://www.reddit.com/r/proceduralgeneration/comments/6mta0f/watercolor_simple_noise_algorithm/&quot;&gt;this Reddit post&lt;/a&gt;, which is the one I tried. The algorithm recursively &lt;em&gt;expands&lt;/em&gt; a small image (here 3 × 3 pixels) by adding a new pixel between the existing ones, and their colour is chosen through a linear interpolation between the neighbouring ones.&lt;/p&gt;

&lt;p&gt;The code here is simply translated into &lt;a href=&quot;https://processing.org/&quot;&gt;Processing&lt;/a&gt; (Java — ew) from the JavaScript implementation:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// https://www.reddit.com/r/proceduralgeneration/comments/6mta0f/watercolor_simple_noise_algorithm/

void setup()
{
  size(700, 700);
  background(100);
  colorMode(RGB, 255, 255, 255, 1);

  // Generate 10 images
  for (int image = 0; image &amp;lt; 10; image++)
  {
    // Seed
    long seed = System.nanoTime();
    randomSeed(seed);

    // Staring size
    int size = 3;

    // The pixels
    color[][] pxs = new color[size][size];

    // Initialize with random colours
    for (int x = 0; x &amp;lt; size; x++)
    {
      for (int y = 0; y &amp;lt; size; y++)
      {
        pxs[x][y] = color(random(255), random(255), random(255));
      }
    }

    // Zoom iterations
    int zoom = 8;

    // Zoom
    for (int z = 0; z &amp;lt; zoom; z++)
    {
      // Expand size
      size = (size * 2) - 1;

      // Create new array of zoomed pixels
      color[][] zoomedPxs = new color[size][size];

      // Set colours by 2x2 pixels chunks, with the top left of the original colour
      for (int x = 0; x &amp;lt; size; x += 2)
      {
        for (int y = 0; y &amp;lt; size; y += 2)
        {
          // Top left is the original
          zoomedPxs[x][y] = pxs[x / 2][y / 2];

          // Top right
          if (x &amp;lt; size - 1)
          {
            float r = random(1);
            zoomedPxs[x + 1][y] = lerpColor(pxs[x / 2][y / 2], pxs[x / 2 + 1][y / 2], r);
          }

          // Bottom left
          if (y &amp;lt; size - 1)
          {
            float r = random(1);
            zoomedPxs[x][y + 1] = lerpColor(pxs[x / 2][y / 2], pxs[x / 2][y / 2 + 1], r);
          }

          // Bottom right
          if (x &amp;lt; size - 1 &amp;amp;&amp;amp; y &amp;lt; size - 1)
          {
            float r1 = random(1);
            float r2 = random(1);
            color c1 = lerpColor(pxs[x / 2][y / 2], pxs[x / 2 + 1][y / 2 + 1], r1);
            color c2 = lerpColor(pxs[x / 2][y / 2 + 1], pxs[x / 2 + 1][y / 2], r2);
            float r3 = random(1);
            zoomedPxs[x + 1][y + 1] = lerpColor(c1, c2, r3);
          }
        }
      }

      // Save zoomed pixels
      pxs = zoomedPxs;
    }

    print(pxs);

    save(&quot;output/watercolor_&quot; + seed + &quot;.tif&quot;);
  }
}

void print(color[][] pxs)
{
  int side = ceil((float)width / pxs.length);
  noStroke();
  for (int x = 0; x &amp;lt; pxs.length; x++)
  {
    for (int y = 0; y &amp;lt; pxs.length; y++)
    {
      for (int sx = 0; sx &amp;lt; side; sx++)
      {
        for (int sy = 0; sy &amp;lt; side; sy++)
        {
          set(side * x + sx, side * y + sy, pxs[x][y]);
        }
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="procedural generation" /><category term="Java" /><summary type="html"></summary></entry><entry><title type="html">Idliketogohome</title><link href="http://localhost:4000/portfolio/idliketogohome/" rel="alternate" type="text/html" title="Idliketogohome" /><published>2019-01-27T00:00:00+00:00</published><updated>2019-01-27T00:00:00+00:00</updated><id>http://localhost:4000/portfolio/idliketogohome</id><content type="html" xml:base="http://localhost:4000/portfolio/idliketogohome/">&lt;p&gt;&lt;img src=&quot;/portfolio/assets/idliketogohome/h1.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/portfolio/assets/idliketogohome/h2.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;/portfolio/assets/idliketogohome/h3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I made &lt;em&gt;I’d like to go home&lt;/em&gt; during the 48h of the &lt;a href=&quot;https://globalgamejam.org/&quot;&gt;Global Game Jam&lt;/a&gt; 2019. &lt;a href=&quot;https://marcomoroni.itch.io/id-like-to-go-home&quot;&gt;Play it on itch.io!&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This year I decided to go all solo: I drew the assets and I used &lt;a href=&quot;https://unity3d.com/&quot;&gt;Unity&lt;/a&gt; to build it. It’s made with 2D sprites in a 3D side-scrolling scene.&lt;/p&gt;

&lt;p&gt;It’s a short story about a rabbit that lost his way home. My attention was all on the &lt;em&gt;immersion&lt;/em&gt; of the player and the art-style was inspired by &lt;a href=&quot;http://jonklassen.tumblr.com/&quot;&gt;Jon Klassen&lt;/a&gt;—for the characters and the story—and &lt;a href=&quot;https://galshir.com/&quot;&gt;Gal Shir&lt;/a&gt;—for the colours and the vegetation.&lt;/p&gt;

&lt;p&gt;Some technical insights:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The background seems to be of one solid dark purple: the 3D plane on the ground has a shader that outputs a solid colour that is not affected by anything (just like a sprite) and the camera outputs the same colour when there are no elements on the screen. In this way you cannot see where the plane ends, and it gives the impression of a consistent colour.&lt;/li&gt;
  &lt;li&gt;The camera is controlled by Unity’s Cinemachine and it has a noise and vignette post-processing effect.&lt;/li&gt;
  &lt;li&gt;The sprites are generally made in two steps: first, draw the basic shape with a solid colour; second, use a sand/spray brush to add a secondary colour.&lt;/li&gt;
  &lt;li&gt;There is what seems to be a 3D model of a home: at the time of writing I don’t know how to 3D model, so I simply assembled it with some sprites (&lt;em&gt;hehe&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All the code is in &lt;a href=&quot;https://github.com/marcomoroni/ggj-2019&quot;&gt;here&lt;/a&gt;, and you can &lt;a href=&quot;https://marcomoroni.itch.io/id-like-to-go-home&quot;&gt;play it online on itch.io&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><category term="game jam" /><category term="games dev" /><category term="unity" /><category term="C#" /><summary type="html"></summary></entry><entry><title type="html">Tabletop</title><link href="http://localhost:4000/portfolio/tabletop/" rel="alternate" type="text/html" title="Tabletop" /><published>2018-12-19T00:00:00+00:00</published><updated>2018-12-19T00:00:00+00:00</updated><id>http://localhost:4000/portfolio/tabletop</id><content type="html" xml:base="http://localhost:4000/portfolio/tabletop/">&lt;p&gt;This is a tabletop engine made with &lt;a href=&quot;https://unity3d.com/&quot;&gt;Unity&lt;/a&gt;: a player can drag-and-drop cards across different &lt;em&gt;decks&lt;/em&gt; (a &lt;em&gt;deck&lt;/em&gt; is considered a collection of cards that can be laid down in different ways). A developer should be able to easily set up a scene for any board game (not &lt;em&gt;any&lt;/em&gt; but you get the point). To help out developers I built some tools to arrange the scene using the powerful feature of the Unity Editor.&lt;/p&gt;

&lt;p&gt;The Unity Package with a short guide is &lt;a href=&quot;https://github.com/marcomoroni/set10110&quot;&gt;on GitHub&lt;/a&gt;. It’s not &lt;em&gt;complete&lt;/em&gt;, but it should work for simple games.&lt;/p&gt;

&lt;p&gt;This project made me realize how much I enjoy tools development and playing around with the Unity editor. Tools are extremely important especially for big games, and with them I can even do some UX design that I like so much!&lt;/p&gt;

&lt;h3 id=&quot;tabletop-engine&quot;&gt;Tabletop engine&lt;/h3&gt;

&lt;p&gt;The engine based around two concepts: &lt;em&gt;cards&lt;/em&gt; and &lt;em&gt;decks&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A deck takes a &lt;code class=&quot;highlighter-rouge&quot;&gt;TabletopDeckStyle&lt;/code&gt; Scriptable Object as a parameter: it contains the data on how the cards should be placed on the table. &lt;code class=&quot;highlighter-rouge&quot;&gt;TabletopDeckStyle&lt;/code&gt; can be a line or a circle and from the Inspector is possible to change many variable, for example the gap between cards, the max scatter (position and angle), the alignment, etc.&lt;/p&gt;

&lt;p&gt;Cards can be moved around with your cursor or by using simple functions like &lt;code class=&quot;highlighter-rouge&quot;&gt;AddCard()&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;AddCards()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/tabletop/engine01.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;developer-tools&quot;&gt;Developer tools&lt;/h3&gt;

&lt;p&gt;I build a handy Editor Window to manage the cards that will be added to the scene; it was soon clear that that was most necessary tool to have, otherwise every card should have been changed individually. It consists on a database where cards can be added, deleted or duplicated. Once they are ready you only need to click on “Update Scene” to create the cards. The &lt;em&gt;default&lt;/em&gt; values are the ones a new card will have when added. For example, if every card has the same back sprite, set it as default, and every new card will have it.&lt;/p&gt;

&lt;p&gt;Decks have Gizmos to show where cards will be placed once in Game mode. These are always visible and if a deck is selected the gizmos will change color. The whitest gizmo box corresponds to the first (or top) card of a deck.&lt;/p&gt;

&lt;p&gt;Also, all Inspectors are custom made to allow more functionalities and better UI.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/tabletop/database.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/tabletop/inspector.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/tabletop/gizmos.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note that I’m working on &lt;a href=&quot;https://github.com/marcomoroni/onirim&quot;&gt;a proper board game engine&lt;/a&gt; and I want to implement &lt;a href=&quot;https://boardgamegeek.com/boardgame/156336/onirim-second-edition&quot;&gt;Onirim&lt;/a&gt; soon. Also when I did this project I didn’t know about events and delegates = could have been much better.&lt;/em&gt;&lt;/p&gt;</content><author><name></name></author><category term="tools dev" /><category term="unity" /><category term="C#" /><summary type="html">This is a tabletop engine made with Unity: a player can drag-and-drop cards across different decks (a deck is considered a collection of cards that can be laid down in different ways). A developer should be able to easily set up a scene for any board game (not any but you get the point). To help out developers I built some tools to arrange the scene using the powerful feature of the Unity Editor.</summary></entry><entry><title type="html">Ray Tracer</title><link href="http://localhost:4000/portfolio/raytracer/" rel="alternate" type="text/html" title="Ray Tracer" /><published>2018-12-18T00:00:00+00:00</published><updated>2018-12-18T00:00:00+00:00</updated><id>http://localhost:4000/portfolio/ray-tracer</id><content type="html" xml:base="http://localhost:4000/portfolio/raytracer/">&lt;p&gt;&lt;img src=&quot;/portfolio/assets/raytracer/ray02.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Future shines bright for ray tracers, and although the theory behind them is fairly simple, they are magnificently &lt;em&gt;slow&lt;/em&gt;.&lt;/p&gt;

&lt;!--&lt;div style=&quot;background-color: red; height: 40px; width: calc(100vw - 40px); position: relative; left: 50%; margin-left: calc(-50vw + 20px); margin-bottom: 2.8em; margin-top: 2.8em;&quot;&gt;
&lt;/div&gt;--&gt;

&lt;p&gt;I investigated different parallelization ways to speed up a path tracer. I used &lt;em&gt;&lt;a href=&quot;http://www.kevinbeason.com/smallpt/&quot;&gt;smallpt&lt;/a&gt;&lt;/em&gt; as a base, but to keep it as simple as possible I removed unnecessary features such as pixel subdivision and tent filter.&lt;/p&gt;

&lt;p&gt;The two methods that I implemented are &lt;a href=&quot;https://www.openmp.org/&quot;&gt;OpenMP&lt;/a&gt; for CPU parallelization and &lt;a href=&quot;https://developer.nvidia.com/cuda-zone&quot;&gt;CUDA&lt;/a&gt; for GPU parallelization. They both target the loop that iterates through all the pixels.&lt;/p&gt;

&lt;p&gt;You can already find an OpenMP in &lt;em&gt;samllpt&lt;/em&gt;, and it consists in one single line. CUDA implementation took a bit more effort, especially because when you put too much data into the GPU there’s no easy way to tell whether it’s going to crash. It just happens.&lt;/p&gt;

&lt;p&gt;By the end, an image with a resolution of 1024 × 768 pixels with 100 samples per pixel took:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;94 seconds with sequential code&lt;/li&gt;
  &lt;li&gt;15 seconds with OpenMP&lt;/li&gt;
  &lt;li&gt;2 seconds with CUDA&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The repo is &lt;a href=&quot;https://github.com/marcomoroni/set10108&quot;&gt;here&lt;/a&gt; and it also contains a detailed report of the work.&lt;/p&gt;</content><author><name></name></author><category term="graphics" /><category term="parallel programming" /><category term="C++" /><summary type="html"></summary></entry><entry><title type="html">Clock</title><link href="http://localhost:4000/portfolio/clock/" rel="alternate" type="text/html" title="Clock" /><published>2018-09-09T00:00:00+01:00</published><updated>2018-09-09T00:00:00+01:00</updated><id>http://localhost:4000/portfolio/clock</id><content type="html" xml:base="http://localhost:4000/portfolio/clock/">&lt;p&gt;&lt;img src=&quot;/portfolio/assets/clock/clock-sand.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/clock/clock-sky.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This is the clock you can find on my phone home screen. I made it using &lt;a href=&quot;https://play.google.com/store/apps/details?id=org.kustom.wallpaper&amp;amp;hl=en_GB&quot;&gt;KWLP&lt;/a&gt; and it was inspired by the Prague astronomical clock (that you can see below) and possibly by Dumbledore’s pocket watch.&lt;/p&gt;

&lt;p class=&quot;no-modal&quot;&gt;&lt;img src=&quot;/portfolio/assets/clock/fabrizio-verrecchia-180315-unsplash.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Here’s how it works:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/clock/clock-explained.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You’re probably wondering &lt;em&gt;why&lt;/em&gt;. That’s a very good question.&lt;/p&gt;</content><author><name></name></author><category term="android" /><summary type="html"></summary></entry><entry><title type="html">Azucena</title><link href="http://localhost:4000/portfolio/azucena/" rel="alternate" type="text/html" title="Azucena" /><published>2018-05-02T00:00:00+01:00</published><updated>2018-05-02T00:00:00+01:00</updated><id>http://localhost:4000/portfolio/azucena</id><content type="html" xml:base="http://localhost:4000/portfolio/azucena/">&lt;p&gt;&lt;em&gt;Azucena&lt;/em&gt; has been my first complete game. &lt;a href=&quot;https://marcomoroni.github.io/azucena/&quot;&gt;This is its website&lt;/a&gt;!&lt;/p&gt;

&lt;p&gt;I made this game as a university coursework, and the project included a pitch presentation and a game design document.&lt;/p&gt;

&lt;p&gt;I took inspiration mainly from two games: &lt;em&gt;The Legend of Zelda&lt;/em&gt; and &lt;em&gt;&lt;a href=&quot;http://www.heart-machine.com/&quot;&gt;Hyper Light Drifter&lt;/a&gt;&lt;/em&gt;. You play as Azucena, a llama who has to rescue her three babies. Each of them is waiting at the end of a level and the levels can be visited in any order.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/azucena/capture_01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;It runs on an engine built from scratch in C++, with the help of &lt;a href=&quot;https://www.sfml-dev.org/&quot;&gt;SFML&lt;/a&gt; and &lt;a href=&quot;https://github.com/erincatto/Box2D&quot;&gt;Box2D&lt;/a&gt;. The pieces are the same you would expect to find in any game engine: scenes, entities, components, etc. The game has all the basic technical features necessary to consider a game &lt;em&gt;a game&lt;/em&gt;, for example: a menu, save and load, a tutorial, an ending, sounds and music, support for different screen resolutions, remappable controls and joystick support.&lt;/p&gt;

&lt;p&gt;Before this project, I used to use Unity for very simple tasks, without having a deep understanding of the engine and its potential. After completing the project I saw the light! Game engines now made complete sense: this project was a turning point for me because I created a &lt;em&gt;tiny&lt;/em&gt; engine, very similar to Unity (and others), and it boosted my confidence to the sky.&lt;/p&gt;

&lt;p&gt;The source code is &lt;a href=&quot;https://github.com/marcomoroni/azucena&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/azucena/capture_04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/azucena/capture_02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/azucena/capture_03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="games dev" /><category term="C++" /><summary type="html">Azucena has been my first complete game. This is its website!</summary></entry><entry><title type="html">Lens Vr</title><link href="http://localhost:4000/portfolio/lens-vr/" rel="alternate" type="text/html" title="Lens Vr" /><published>2018-05-01T00:00:00+01:00</published><updated>2018-05-01T00:00:00+01:00</updated><id>http://localhost:4000/portfolio/lens-vr</id><content type="html" xml:base="http://localhost:4000/portfolio/lens-vr/">&lt;p&gt;&lt;img src=&quot;/portfolio/assets/lens-vr/capture07.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This experimental VR application developed for &lt;a href=&quot;https://www.disneyresearch.com/&quot;&gt;Disney Research&lt;/a&gt; lets you navigate through a dataset. One of the controllers is a lens that distorts what you see and magnifies a certain area.&lt;/p&gt;

&lt;p&gt;I worked in a team of six people, and I was responsible for:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;setting up and supervising version control on GitHub. For this, I also prepared cheat sheets for who was less familiar with Git and GitHub;&lt;/li&gt;
  &lt;li&gt;the importation and visualization of the datasets in the &lt;a href=&quot;https://unity3d.com/&quot;&gt;Unity&lt;/a&gt; engine;&lt;/li&gt;
  &lt;li&gt;the user experience, namely the controls and the UI in the controllers: the user points a &lt;em&gt;laser&lt;/em&gt; or use a lens with its right hand, while it can read data details on a surface on its left hand.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It was awarded as the second best group project of the year, but this doesn’t mean everything went perfectly. For me, the biggest problem we had during the development was that we were not entirely sure what was the final use of it: I think it’s important for people to be motivated to know were their project will be used and why is it important. In any case, a positive attitude sometimes it’s all that’s needed!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/lens-vr/capture05.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/lens-vr/capture06.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/lens-vr/capture03.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/lens-vr/capture01.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/lens-vr/capture02.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/lens-vr/capture04.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/lens-vr/capture08.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="unity" /><category term="vr" /><category term="data visualisation" /><category term="c#" /><summary type="html"></summary></entry><entry><title type="html">Physics Based Animation</title><link href="http://localhost:4000/portfolio/pba/" rel="alternate" type="text/html" title="Physics Based Animation" /><published>2017-12-01T00:00:00+00:00</published><updated>2017-12-01T00:00:00+00:00</updated><id>http://localhost:4000/portfolio/physics-based-animation</id><content type="html" xml:base="http://localhost:4000/portfolio/pba/">&lt;p&gt;This is a set of physics-based animations I made at university using C++. &lt;a href=&quot;https://github.com/marcomoroni/set09119&quot;&gt;Here’s the code on GitHub&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;flag&quot;&gt;Flag&lt;/h3&gt;

&lt;p&gt;These particles are connected by springs and I applied an isotropic wind to the the triangulated cloth (not to each individual particles).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/pba/flag.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;point-gravity&quot;&gt;Point gravity&lt;/h3&gt;

&lt;p&gt;Here you can see a group of particles that are affected by two points of gravity. The gravity, just as you would expect, is stronger the closer to these points and null after a certain set distance.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/pba/point.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;newtons-gravity-between-any-two-bodies&quot;&gt;Newton’s gravity between any two bodies&lt;/h3&gt;

&lt;p&gt;While the previous simulation does not use any physically correct gravitational formula, this one uses Newton’s law of gravity: every two particles with mass are affected by each other. To be able to see such interactions I decided to make them stick together once they get very close.&lt;/p&gt;

&lt;p&gt;The lighter particle has a higher mass.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/pba/newton.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;super-mario-galaxys-gravity&quot;&gt;&lt;em&gt;Super Mario Galaxy&lt;/em&gt;’s gravity&lt;/h3&gt;

&lt;p&gt;In &lt;em&gt;Super Mario Galaxy&lt;/em&gt; the player is able to walk in planetoids of any shape and size. This is possible because bodies are affected by the gravity of only one planetoid at once and the gravity direction is the inverse of the normal of (usually) the closest surface.&lt;/p&gt;

&lt;p&gt;I’ve managed to apply this principle to particles in box-shaped planetoids. The gravity direction is the normalised vector from the particle to a point &lt;em&gt;U&lt;/em&gt;, where &lt;em&gt;U&lt;/em&gt; is the point on (or in) the planetoid closest to the particle.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/pba/smg.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;rigidbody-obb&quot;&gt;RigidBody (OBB)&lt;/h3&gt;

&lt;p&gt;This is a rigidbody with the shape of a box (OBB) colliding with a plane.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/pba/cube.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;collisions-between-obbs&quot;&gt;Collisions between OBBs&lt;/h3&gt;

&lt;p&gt;This last simulation has two OBBs colliding with each other.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/portfolio/assets/pba/domino.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="physics" /><category term="C++" /><summary type="html">This is a set of physics-based animations I made at university using C++. Here’s the code on GitHub.</summary></entry><entry><title type="html">Website</title><link href="http://localhost:4000/portfolio/site/" rel="alternate" type="text/html" title="Website" /><published>2017-05-01T00:00:00+01:00</published><updated>2017-05-01T00:00:00+01:00</updated><id>http://localhost:4000/portfolio/website</id><content type="html" xml:base="http://localhost:4000/portfolio/site/">&lt;p&gt;I hope you’re enjoying this simple website because I took care of every pixel.&lt;/p&gt;

&lt;p&gt;I like essential design, and you’ve probably noticed. I used warm colours and only one accent colour for interactive elements. There are no shadows and no rounded corners. It was very important for me to have visual consistency and a pleasant experience overall.&lt;/p&gt;

&lt;p&gt;The abstract (or title) of each portfolio entry uses a monospace font: this makes it easier to recognize this element throughout the site and it highlights the fact that this is a portfolio of a developer. They all have tags to easily categorize them.&lt;/p&gt;

&lt;p&gt;The navigation buttons are at the bottom of each page, beginning from the home. By following it, the user can have a look at all my works in one go. The content of every page is simple and concise with big pictures whenever possible. This is so because the user is most likely an employer, and they have a bunch of other portfolios waiting after mine. &lt;em&gt;Isn’t that right, mr. employer?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;On the top left corner there’s an additional &lt;em&gt;Home&lt;/em&gt; button. I would have preferred not to have it, but usability is important.&lt;/p&gt;

&lt;p&gt;I used &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt; to build it from the ground up. I’m not a web developer but hey, it came out pretty good!&lt;/p&gt;</content><author><name></name></author><category term="web" /><category term="ui / ux" /><summary type="html">I hope you’re enjoying this simple website because I took care of every pixel.</summary></entry></feed>